#!/usr/bin/env perl
# vim:set sts=4 ts=4 sw=4 expandtab:
# xterms - start a bunch of xterms
# Created: Fri Jul 25 09:09:18 MYT 2008

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use File::Slurp;
use FindBin;
use lib "$FindBin::RealBin";
use WMGR home => "$FindBin::RealBin";
use Screen;

my $TMP_DIR = '/dev/shm';
my $geom = qx/xrandr | grep '\*'/;

my $muxer = WMGR::get_config('muxer');
checkMuxerCapabilities($muxer);
$muxer->clean();

my $two_display_width = 3360;
my $offset_x = 0;
if ($geom =~ /$two_display_width/) {
    $offset_x = $two_display_width / 2;
}

my $full_rows=69;
my $offset_y = '+-2'; # '+-15';
# Need to add 1680 for two monitors
my $geometries = get_geometries(fallback => {
    #logs      => '209x60-' . (0) . '+0',
    any    => "116x$full_rows-" . ($offset_x + 0) . $offset_y,    # anything goes
    #rtfm      => '100x83+' . ($offset_x + 247) . '+0',    # read man pages here
    #gits      => '140x83+' . ($offset_x + 403) . '+0',
    # hilite => "153x32-3" . $offset_y,
    full   => "239x55+" . ($offset_x + 0) . $offset_y,
    shells => "86x$full_rows+-1" . $offset_y,
    vims   => "86x$full_rows+689" . $offset_y,
    }
);

my $xterms = {};

my ($bg, $fg) = qw/black white/;

my %opts;
getopts('b:ehl', \%opts) or do { usage(); exit 1; };
if (defined $opts{e}) {
    system("vim ~/wmgr/xterms.conf.pl");
    exit(0);
}
if (defined $opts{h}) {
    usage();
    exit(0);
}
if (defined $opts{l}) {
    my @list = $muxer->list();
    foreach my $key (sort keys %$geometries) {
        print "$key\t=> $geometries->{$key}\n";
    }
    print "===\n";
    my $fmt = "%-8s %-8s %-22s %s\n";
    printf $fmt, qw(PID NAME DATE STATE);
    foreach my $s (@list) {
        my %s = %$s;
        printf $fmt, @s{qw(pid name date status)};
    }
    exit 0;
}
if (defined $opts{b}) {
    $bg = $opts{b};
    $fg = ($bg eq 'white') ? 'black' : 'white';
}

foreach my $session (keys %$geometries) {
    my $executable = $muxer->runner($session);
    my ($first_letter) = $session =~ /(.).*/;
    my ($title) = "term.$first_letter";

    $xterms->{$session} = "TERM_NAME=$session SHORT_TERM_NAME=$first_letter "
                        . "XTERMS_BG=$bg XTERMS_FG=$fg "
                        # .  "xfce4-terminal "
                        # .  "gnome-terminal "
                        # .  "rxvt-unicode "
                        # . "xterm "
                        # . "/usr/local/bin/uxterm "
                        . "/usr/bin/uxterm "
                        # . "/usr/local/bin/xterm -u8 "

                        # gnome-terminal:
                        # .  "--title term.$session "
                        # xterm:
                        .  "-title $title "
                        .  "-fg $fg -bg $bg "
                        .  "-b 0 "
                        # Do not scroll window on new output
                        . "-si "

                        # xfce4-terminal:
                        # .  "--geometry=". $geometries->{$session} . " "
                        # rxvt-unicode:
                        # .  "--geometry ". $geometries->{$session} . " "
                        # xterm:
                        .  "-geometry ". $geometries->{$session} . " "

                        .  "-e $executable  &";
}

my @torun;

if (defined($ARGV[0])) {
  if ($ARGV[0] eq 'restart') {
    restart_and_exit();
  } elsif ($ARGV[0] eq 'stop') {
    restart_and_exit('exit');
  } elsif ($ARGV[0] eq 'repos') {
    print "Todo: resposition xterms windows\n";
  }

  # Start only the given session names
  foreach my $which (split(/,/, $ARGV[0])) {
    foreach my $session_name (keys %$xterms) {
        if ($session_name =~ /^$which/) {
            push @torun, $session_name;
        }
    }
  }

  if (scalar @torun == 0) {
    print "No session matches $ARGV[0]\n";
    exit 1;
  }
} else {
  my $muxer_status = $muxer->status();
  foreach my $session_name (keys %{$xterms}) {
    if ($muxer->isDetached($muxer_status, $session_name)) {
        push @torun, $session_name
    }
  }
}


foreach my $which (@torun) {
    my $cmd = $xterms->{$which};
    my $cmd_to_print = $cmd;
    $cmd_to_print =~ s/ -/ \\\n\t-/g;
    print "$cmd_to_print\n";
    system("cd $ENV{HOME}; $cmd");
}
sleep 2; update_winid(@torun);
#`(sleep 4 && cwd=$cwd $cwd/xterms.seticons.sh )&`;
my $wmgr_home = $FindBin::RealBin;
`cwd=$wmgr_home $wmgr_home/xterms.seticons.sh &`;

system("if ps -ef|grep xbindkeys|grep -q -v grep; then :; else $wmgr_home/xbind; fi");

sub get_geometries {
    my ($dummy, $fallback) = @_;

    return WMGR::get_config('geometries') || $fallback;
}

sub usage {
  print <<USAGE;
NAME
    xterms - Start a bunch of terminals

SYNOPSIS
    xterms [-h]
    xterms [-b <background color>] [session1,session2,...]
    xterms [-l]
    xterms [-e]
    xterms restart <options and arguments>

DESCRIPTION
    xterms starts the terminals with the geometries set in the config file
    xterms.conf.pl

    "xterms restart [args]" restarts itself after killing all xterm terminals.

    The argument [session1,session2,...] limits the terminals to be started.
    Default is to start all terminals.

OPTIONS
    -h
       Shows this help message

    -b <background color>
       Sets the background color. This implictly sets the foreground color too.
       If the backgroudn color is white, the foreground color is set to black.
       For all other backgroud color, the foreground color is set to white.

       The background and foreground colors are exported as environment
       variable XTERMS_BG and XTERMS_FG in the terminals.

    -e
       Edits the configuration file xterms.pl.conf

    -l
       List sessions found in xterms.conf.pl
USAGE
}

sub update_winid {
    my (@to_run) = @_;

    my (@cmds) = map { $xterms->{$_} } @to_run;
    my (@new_titles) = map { $_ =~ s/.*-title //; $_ =~ s/ .*//; $_ } @cmds;

    my @term_list = `wmctrl -l|grep ' term.[a-z]\$'`;
    my %winids;
    foreach my $line (@term_list) {
        chomp $line;
        my (@e) = split(/  */, $line);
        #0x03200024  0 a term.f
        my $id = $e[0];
        my $title = $e[3];
        $winids{$title} = $id;
    }

    my $xwininfo = {};
    foreach my $title (@new_titles) {
        write_file("$TMP_DIR/$title.winid", oct($winids{$title}));
        save_window_geometry($winids{$title});
    }
}

sub save_window_geometry {
    my ($id) = @_;
    my $wininfo = qx/xwininfo -id $id/;
    my ($term, $x, $y, $w, $h, $col, $row)
        = $wininfo =~ /
            .*Window.id:.*0x[^ ]+\s+"([^"]+)"
            .*Absolute.upper-left.X:\s+(\d+)
            .*Absolute.upper-left.Y:\s+(\d+)
            .*Width:\s+(\d+)
            .*Height:\s+(\d+)
            .*-geometry.(\d+)x(\d+)
        /gxms;

    print "$term $x $y $w $h $row $col\n";
    my ($k) = $term =~ /\.(.)/;
    my $dir = "/dev/shm/term/$k";
    qx/mkdir -p $dir/;
    write_file($dir . "/w", $w);
    write_file($dir . "/h", $h);
    write_file($dir . "/x", $x);
    write_file($dir . "/y", $y);
    write_file($dir . "/row", $row);
    write_file($dir . "/col", $col);
}

sub restart_and_exit {
    my ($quit) = @_;
    $quit ||= '';

    shift @ARGV;
    my $args = join(' ', @ARGV);
    system(<<"    SHELL"
        nohup sh -c '
            echo " xterms $args"
            killall xterm
            while pidof xterm; do
                sleep .2
            done
            rm -f $TMP_DIR/term.?.winid
            sleep 1 # Avoid deadlock
            $quit
            xterms $args
        ' > ~/wmgr/nohup.xterm.restart.log 2>&1 &
    SHELL
    );
    exit(0);
}

sub checkMuxerCapabilities {
    my ($muxer) = @_;
    my @abilities = qw(list status isDetached clean runner cmd_dump);
    # cmd_dump needed by ./dump
    my @errors;
    foreach my $sub (@abilities) {
        unless ($muxer->can($sub)) {
            push @errors, $sub;
        }
    }

    if (@errors) {
        die join("\n\t", "Missing subs in $muxer:", @errors);
    }
}
