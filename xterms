#!/usr/bin/env perl
# vim:set sts=4 ts=4 sw=4 expandtab:
# xterms - start a bunch of xterms
# Created: Fri Jul 25 09:09:18 MYT 2008

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use File::Slurp;

qx/screen -wipe/;

my $TMP_DIR = '/dev/shm';
my $cwd = dirname(__FILE__);
my $geom = qx/xrandr | grep '\*'/;

my $two_screen_width = 3360;
my $offset_x = 0;
if ($geom =~ /$two_screen_width/) {
    $offset_x = $two_screen_width / 2;
}

my $full_rows=69;
my $offset_y = '+-2'; # '+-15';
# Need to add 1680 for two monitors
my $geometries = get_geometries(fallback => {
    #logs      => '209x60-' . (0) . '+0',
    any    => "116x$full_rows-" . ($offset_x + 0) . $offset_y,    # anything goes
    #rtfm      => '100x83+' . ($offset_x + 247) . '+0',    # read man pages here
    #gits      => '140x83+' . ($offset_x + 403) . '+0',
    # hilite => "153x32-3" . $offset_y,
    full   => "239x55+" . ($offset_x + 0) . $offset_y,
    shells => "86x$full_rows+-1" . $offset_y,
    vims   => "86x$full_rows+689" . $offset_y,
    }
);

my $xterms = {};

my ($bg, $fg) = qw/black white/;

my %opts;
getopts('b:hl', \%opts);
if (defined $opts{h}) {
    usage();
    exit(0);
}
if (defined $opts{l}) {
    print join("\n", keys %$geometries) . "\n";
    exit 0;
}
if (defined $opts{b}) {
    $bg = $opts{b};
    $fg = ($bg eq 'white') ? 'black' : 'white';
}

foreach my $session (keys %$geometries) {
    my $executable = "$cwd/screen.$session";
    if ( not -f $executable  ) {
        $executable = "screen -DR $session";
        # croak "The file screen.$executable does not exist.\n".
        #       "Its content should be somewhat like this:\n".
        #       "screen -DR man\n";
    }
    my ($title) = "term.$session" =~ /(term..).*/;

    $xterms->{$session} = "TERM_NAME=$session XTERMS_BG=$bg XTERMS_FG=$fg "

                        # .  "xfce4-terminal "
                        # .  "gnome-terminal "
                        # .  "rxvt-unicode "
                        # . "xterm "
                        # . "/usr/local/bin/uxterm "
                        . "/usr/bin/uxterm "
                        # . "/usr/local/bin/xterm -u8 "

                        # gnome-terminal:
                        # .  "--title term.$session "
                        # xterm:
                        .  "-title $title "
                        .  "-fg $fg -bg $bg "
                        .  "-b 0 "
                        # Do not scroll window on new output
                        . "-si "

                        # xfce4-terminal:
                        # .  "--geometry=". $geometries->{$session} . " "
                        # rxvt-unicode:
                        # .  "--geometry ". $geometries->{$session} . " "
                        # xterm:
                        .  "-geometry ". $geometries->{$session} . " "

                        .  "-e $executable  &";
}

my @torun;

if (defined($ARGV[0])) {
  if ($ARGV[0] eq 'restart') {
    restart_and_exit();
  }

  # Start only the given session names
  foreach my $which (split(/,/, $ARGV[0])) {
    foreach my $session_name (keys %$xterms) {
        if ($session_name =~ /^$which/) {
            push @torun, $session_name;
        }
    }
  }

  if (scalar @torun == 0) {
    print "No session matches $ARGV[0]\n";
    exit 1;
  }
} else {
  my $screen_status = get_screen_status();
  foreach my $which (keys %{$xterms}) {
    push @torun, $which if ok_to_run($which, $screen_status);
  }
}


foreach my $which (@torun) {
    my $cmd = $xterms->{$which};
    my $cmd_to_print = $cmd;
    $cmd_to_print =~ s/ -/ \\\n\t-/g;
    print "$cmd_to_print\n";
    system("cd $ENV{HOME}; $cmd");
}
sleep 2; update_winid(@torun);
#`(sleep 4 && cwd=$cwd $cwd/xterms.seticons.sh )&`;
`cwd=$cwd $cwd/xterms.seticons.sh &`;

system("if ps -ef|grep xbindkeys|grep -q -v grep; then :; else  $cwd/xbind; fi");

sub get_geometries {
    my ($dummy, $fallback) = @_;

    return get_config('geometries') || $fallback;
}

sub get_config {
    my ($entry) = @_;

    my $medir = dirname(__FILE__);
    my $conf_file = "$medir/xterms.conf.pl";
    if (! -f $conf_file) {
        return undef;
    }

    my %config = eval read_file($conf_file) or die "Corrupt $conf_file? $@";
    return $config{$entry};
}

sub get_screen_status {
  # output of screen -ls:
  #    There are screens on:
  #  <tab>5138.vims           <tab>(Attached)
  #     24754.anything           (Attached)
  #     24752.session            (Attached)
  #     24748.shells             (Attached)
  #    5 Sockets in /var/run/screen/S-user.
  my @screen_list = `screen -ls|grep '^\t'`;
  my $screen_status = {};
  foreach my $screen_session (@screen_list) {
    chomp $screen_session;
    my ($empty, $pid_name, $date, $status) = split(/\t/, $screen_session);
    $pid_name =~ /([0-9])+\.(.*)/;
    my $name = $2;
    $screen_status->{$name} = $status;
  }
  return $screen_status;
}

# ok to run means:
#   The screen does not exist OR The screen is detached.
sub ok_to_run {
  my $which = shift;
  my $screen_status = shift;

  if (!defined($screen_status->{$which})) {
    return 1;
  }
  if ($screen_status->{$which} eq '(Detached)') {
    return 1;
  }

  return 0;
}

sub usage {
  print <<USAGE;
NAME
    xterms - Start a bunch of terminals

SYNOPSIS
    xterms [-h]
    xterms [-b <background color>] [session1,session2,...]
    xterms [-l]
    xterms restart <options and arguments>

DESCRIPTION
    xterms starts the terminals with the geometries set in the config file
    xterms.conf.pl

    "xterms restart" restarts itself after killing all xterm terminals.

    The argument [session1,session2,...] limits the terminals to be started.
    Default is to start all terminals.

OPTIONS
    -h
       Shows this help message

    -b <background color>
       Sets the background color. This implictly sets the foreground color too.
       If the backgroudn color is white, the foreground color is set to black.
       For all other backgroud color, the foreground color is set to white.

       The background and foreground colors are exported as environment
       variable XTERMS_BG and XTERMS_FG in the terminals.

    -l
       List sessions found in xterms.conf.pl
USAGE
}

sub update_winid {
    my (@to_run) = @_;

    my (@cmds) = map { $xterms->{$_} } @to_run;
    my (@new_titles) = map { $_ =~ s/.*-title //; $_ =~ s/ .*//; $_ } @cmds;

    my @term_list = `wmctrl -l|grep ' term.[a-z]\$'`;
    my %winids;
    foreach my $line (@term_list) {
        chomp $line;
        my (@e) = split(/  */, $line);
        #0x03200024  0 a term.f
        my $id = $e[0];
        my $title = $e[3];
        $winids{$title} = $id;
    }

    foreach my $title (@new_titles) {
        my $cmd = "echo $winids{$title} > $TMP_DIR/$title.winid";
        print $cmd . "\n";
        system($cmd);
    }
}

sub restart_and_exit {
    shift @ARGV;
    my $args = join(' ', @ARGV);
    system(<<"    SHELL"
        nohup sh -c '
            echo " xterms $args"
            killall xterm
            while pidof xterm; do
                sleep .2
            done
            rm -f $TMP_DIR/term.?.winid
            sleep 1 # Avoid deadlock
            xterms $args
        ' > ~/wmgr/nohup.xterm.restart.log 2>&1 &
    SHELL
    );
    exit(0);
}
